# 【2023最新版】React(v18)完全入門ガイド | Hooks,Nextjs,Redux,TypeScript

## セクション3 jsの記法について
./react-guide-material/03_js_basic

### アロー関数

### Import/Export
- export default はデフォルトでExportされる
  - Importする時は{}で囲う必要がない
  - export defaultしていないfunc等は{}で囲う必要がある

### コールバック関数

### 分割代入
- 配列を代入するときは順番が一致している必要がある
- オブジェクトを代入する時はプロパティ名(キー)が一致している必要がある
  - 逆にキーが一致していれば順番は関係ない

### スプレッド演算子
``` javascript
let arr = [1,2,3];
// =で代入
let newArr = arr;
// スプレッド演算子
let newArrSp = [...arr1];
```

- 配列を"="を使って代入をすると、代入元の配列と代入後の配列が同じものとして扱われる
  - だから代入後の配列に何か要素を追加したりすると、代入元の配列にも同じく要素が追加されてしまう
- スプレット演算子を利用すると代入元の配列を展開して全く新しい配列として定義することができる
  - 代入後の配列に何か要素を追加したりしても代入元の配列に変化が起こらないようになっている

### 三項演算子
変数 ? true : false;
ex)
``` javascript
const a = true;
let result = a ? "trueだよ" : "falseだよ";
```

### truthyな値、falsyな値
- falsy：真偽値に変換した際に"偽(false)"とみなされる値のこと。
- truthy：それ以外

```
/* POINT falsyな値の一覧
false
0 (数字)
0n (big int)
"" (空文字)
null
undefined
NaN (Not a Number)
*/
```

### Promise
- 非同期処理とは
  - 記載された順番通りに処理が行われないもの
    - setTimeoutとか
- Promiseとは
  - 非同期処理が終わった後に特定の処理を繋げることができる

``` javascript
let a = 0;

new Promise((resolve, reject) => {
    setTimeout(() => {
        a = 1;
        // resolveだとthen
        resolve(a)
        // rejectだとcatchが実行される
        // reject(a)
    }, 2000);
}).then((b) => {
    console.log(b);
    return b;
}).then((b) => {
    console.log(b);
}).catch((c) => {
    console.log('catchが実行', c)
})
```

### await/async
- await/async は Promiseを簡略化/使いやすくしたもの
  - resolveが呼ばれるまで処理がawaitで待機する

``` javascript
let a = 0;

init();
async function init() {
    try {
        const result = await new Promise((resolve, reject) => {
            setTimeout(() => {
                a = 1;
                reject(a)
            }, 2000);
        })
            console.log(result);
    } catch(e) {
        console.log('catchが実行', e)
    }
    
    // }).catch((c) => {
    //     console.log('catchが実行', c)
    // })
    
}
```


## セクション4 まずはReactに触れてみよう
### propsのルール
- propsは読み取り専用
- propsは親から子にしか渡すことができない

### jsxの正体
- jsxの定義
  - ReactによるJavaScriptの構文を拡張したもの
  - JSXはBABELによってJSのオブジェクトに変換される

```javascript
<h1>Hello!</h1>
↓
React.createElement("tag", "props", "textContent")
React.createElement("h1", null, "Hello!")
```
![JSXがオブジェクトに変換される過程](image.png)

## セクション5 ステートとイベントリスナ
### イベントリスナとは
- 画面上でイベントが発生した時に実行したい関数を登録しておく場所

### 開発でよく使うイベントタイプ
#### 入力イベント
```javascript
<input
  type="text"
  // onChange 入力値の変更を検知
  onChange={() => console.log("onChange検知")}
  // onBlur 入力欄からのフォーカスが消えた時のイベントを検知
  onBlur={() => console.log("onBlur検知")}
  // onFocus フォーカスを検知
  onFocus={() => console.log("onFocus検知")}
/>
```

#### ホバーイベント
```javascript
<div
  className="hover-event"
  onMouseEnter={() => console.log("カーソルが入ってきました。")}
  onMouseLeave={() => console.log("カーソルが出ていきました。")}
>
```

### ステート
- state(状態)とは？
  - コンポーネント毎に保持・管理される値
  - ※コンポーネントないに定義された普通の変数はレンダリングのたびに初期化され、保持されない

### ステートとレンダリングの仕組み
- useStateを使う場合
  - onChange等で変更した値をuseStateで更新すると更新がある度にコンポーネントは再レンダリングされる
- useStateを使わない場合
  - onChange等で変更した値を普通の変数で定義しても再レンダリングはされない → JSX内でリアルタイムに値の変更を表示できない

### ステート使用時の注意点
- useStateはコンポーネント内のトップレベル(階層的な意味)に定義する必要がある
- 値の更新と再レンダリングは予約（非同期）される
- 前回のstate値を使用する場合は更新用関数に関数を渡す
- オブジェクト型のstateを更新する際は新しいオブジェクトを作成する
  - 全く同じオブジェクトだとエラーになる
- stateの値はコンポーネント毎に独立して管理される
- 一度消滅したコンポーネントのstateの値はリセットされる
- stateをpropsとして渡すことで子コンポーネントで利用できる
- コンポーネントの位置によってはstateが維持される

### オブジェクトのステート
- オブジェクト型のステートは新しい値をセットする時も同じ型のオブジェクトを渡す必要がある
  - スプレッド演算子を利用すれば、記述を減らすことができる

```javascript
const personObj = { name: "Tom", age: 18 };
const [person, setPerson] = useState(personObj);

const changeName = (e) => {
    // 全部記述する場合
    setPerson({ name: e.target.value, age: person.age })
    // スプレッド演算子を利用する場合
    setPerson({ ...person, name: e.target.value })
  }

```

